{"mappings":"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","sources":["dist/node_modules/@parcel/runtime-browser-hmr/lib/runtime-4921abf2cd8d7f74.js"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";module.bundle.HMR_BUNDLE_ID = \"7055c94b59712999\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: mixed;\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData = undefined;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets\n/*: {|[string]: boolean|} */\n, acceptedAssets\n/*: {|[string]: boolean|} */\n, assetsToAccept\n/*: Array<[ParcelRequire, string]> */\n;\n\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\n\nfunction getPort() {\n  return HMR_PORT || location.port;\n} // eslint-disable-next-line no-redeclare\n\n\nvar parent = module.bundle.parent;\n\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // Web extension context\n\n  var extCtx = typeof chrome === 'undefined' ? typeof browser === 'undefined' ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n\n  var supportsSourceURL = false;\n\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  } // $FlowFixMe\n\n\n  ws.onmessage = async function (event\n  /*: {data: string, ...} */\n  ) {\n    checkedAssets = {}\n    /*: {|[string]: boolean|} */\n    ;\n    acceptedAssets = {}\n    /*: {|[string]: boolean|} */\n    ;\n    assetsToAccept = [];\n    var data\n    /*: HMRMessage */\n    = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n\n      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH); // Handle HMR Update\n\n      let handled = assets.every(asset => {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n\n      if (handled) {\n        console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n\n        if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n          window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n        }\n\n        await hmrApplyUpdates(assets);\n\n        for (var i = 0; i < assetsToAccept.length; i++) {\n          var id = assetsToAccept[i][1];\n\n          if (!acceptedAssets[id]) {\n            hmrAcceptRun(assetsToAccept[i][0], id);\n          }\n        }\n      } else fullReload();\n    }\n\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      for (let ansiDiagnostic of data.diagnostics.ansi) {\n        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n        console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n      }\n\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe\n\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n\n  ws.onerror = function (e) {\n    console.error(e.message);\n  };\n\n  ws.onclose = function () {\n    console.warn('[parcel] 🚨 Connection to the HMR server was lost');\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel] ✨ Error resolved');\n  }\n}\n\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          🚨 ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div>💡 ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div>📝 <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\n\nfunction fullReload() {\n  if ('reload' in location) {\n    location.reload();\n  } else if (extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  }\n}\n\nfunction getParents(bundle, id)\n/*: Array<[ParcelRequire, string]> */\n{\n  var modules = bundle.modules;\n\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction updateLink(link) {\n  var newLink = link.cloneNode();\n\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n\n  newLink.setAttribute('href', // $FlowFixMe\n  link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe\n\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\n\nvar cssTimeout = null;\n\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href\n      /*: string */\n      = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n\n    cssTimeout = null;\n  }, 50);\n}\n\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n\n      return new Promise((resolve, reject) => {\n        var _document$head;\n\n        script.onload = () => resolve(script);\n\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 ? void 0 : _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\n\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension bugfix for Chromium\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {\n            if (typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n              extCtx.runtime.reload();\n              return;\n            }\n\n            asset.url = extCtx.runtime.getURL('/__parcel_hmr_proxy__?url=' + encodeURIComponent(asset.url + '?t=' + Date.now()));\n            return hmrDownload(asset);\n          }\n\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n\n          (_document$head2 = document.head) === null || _document$head2 === void 0 ? void 0 : _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\n\nfunction hmrApply(bundle\n/*: ParcelRequire */\n, asset\n/*:  HMRAsset */\n) {\n  var modules = bundle.modules;\n\n  if (!modules) {\n    return;\n  }\n\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      } // $FlowFixMe\n\n\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    } else if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\n\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n\n  if (!modules) {\n    return;\n  }\n\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n\n\n    delete modules[id];\n    delete bundle.cache[id]; // Now delete the orphans.\n\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\n\nfunction hmrAcceptCheck(bundle\n/*: ParcelRequire */\n, id\n/*: string */\n, depsByBundle\n/*: ?{ [string]: { [string]: string } }*/\n) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  } // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n\n\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n\n      parents.push(...p);\n    }\n  }\n\n  return accepted;\n}\n\nfunction hmrAcceptCheckOne(bundle\n/*: ParcelRequire */\n, id\n/*: string */\n, depsByBundle\n/*: ?{ [string]: { [string]: string } }*/\n) {\n  var modules = bundle.modules;\n\n  if (!modules) {\n    return;\n  }\n\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n\n  if (checkedAssets[id]) {\n    return true;\n  }\n\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToAccept.push([bundle, id]);\n\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n}\n\nfunction hmrAcceptRun(bundle\n/*: ParcelRequire */\n, id\n/*: string */\n) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n  cached = bundle.cache[id];\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      var assetsToAlsoAccept = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n\n      if (assetsToAlsoAccept && assetsToAccept.length) {\n        // $FlowFixMe[method-unbinding]\n        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);\n      }\n    });\n  }\n\n  acceptedAssets[id] = true;\n}"],"names":["HMR_HOST","HMR_PORT","HMR_SECURE","HMR_ENV_HASH","module","bundle","HMR_BUNDLE_ID","checkedAssets","acceptedAssets","assetsToAccept","OVERLAY_ID","OldModule","Module","moduleName","call","this","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","push","dispose","undefined","getHostname","location","protocol","indexOf","hostname","getPort","port","parent","isParcelRequire","WebSocket","test","ws","extCtx","chrome","browser","supportsSourceURL","eval","err","stack","includes","onmessage","async","event","JSON","parse","type","document","removeErrorOverlay","assets","filter","asset","envHash","every","hmrAcceptCheck","root","id","depsByBundle","console","clear","window","CustomEvent","dispatchEvent","hmrApplyUpdates","i","length","hmrAcceptRun","fullReload","ansiDiagnostic","diagnostics","ansi","codeframe","error","message","hints","join","overlay","createErrorOverlay","html","body","appendChild","onerror","e","onclose","warn","getElementById","remove","log","createElement","errorHTML","diagnostic","frames","reduce","p","frame","encodeURIComponent","code","map","hint","documentation","innerHTML","reload","runtime","getParents","modules","k","d","dep","parents","Array","isArray","concat","updateLink","link","newLink","cloneNode","onload","parentNode","removeChild","setAttribute","getAttribute","split","Date","now","insertBefore","nextSibling","cssTimeout","reloadCSS","setTimeout","links","querySelectorAll","href","servedFromHMRServer","RegExp","origin","hmrDownload","script","src","url","outputFormat","Promise","resolve","reject","_document$head","head","importScripts","__parcel__require__","scriptsToRemove","global","parcelHotUpdate","Object","create","promises","_hmrDownload","catch","getManifest","manifest_version","ServiceWorkerGlobalScope","getURL","all","forEach","hmrApply","_document$head2","deps","oldDeps","hmrDelete","output","orphans","cache","hmrAcceptCheckOne","accepted","v","shift","cached","cb","assetsToAlsoAccept","apply"],"version":3,"file":"index.168ffd0d.js.map"}